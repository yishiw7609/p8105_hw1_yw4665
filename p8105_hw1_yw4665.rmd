---
title: "p8105_hw1_yw4665"
author: "Yishi Wang"
date: "2025-09-18"
output: github_document
---

### Problem 0.1 & 0.2

All requirements and recommendations from Problem 0.1 and 0.2 are properly followed

### Problem 1

Load the 'moderndive' library:
```{r}
library(moderndive)
```

Load the according dataset. Use 'help()' to see dataset description and variable names:
```{r}
data("early_january_weather")
help("early_january_weather")
```
From the RStudio Help panel, we can see that this dataset includes:

**origin**: Weather station. 

**year, month, day, hour**: Time of recording.

**temp, dewp**: Temperature and dewpoint in F.

**humid**: Relative humidity.

**wind_dir, wind_speed, wind_gust**: Wind direction (in degrees), speed and gust speed (in mph).

**precip**: Precipitation, in inches.

**pressure**: Sea level pressure in millibars.

**visib**: Visibility in miles.

**time_hour**: Date and hour of the recording as a POSIXct date.

Now we use 'nrow()' and 'ncol()' to see the size of the dataset:
```{r}
nrow(early_january_weather)
ncol(early_january_weather)
```

Now we use 'mean()' to see the mean temperature:
```{r}
mean(early_january_weather$temp)
```

Next, we make scatter plot using 'ggplot2' package. First load 'ggplot2':
```{r}
library(ggplot2)
```
Now we create a scatterplot named "plot_time_temp" with proper titles and different colorings based on humid variable. 
```{r}
plot_time_temp = ggplot(
  early_january_weather, 
  aes(x = time_hour, y = temp, color = humid)) +
  geom_point() +
  labs(title = "Temperature vs Time",
       x = "Time (hour)",
       y = "Temperature (F)",
       )
plot_time_temp
```
From the plot we can see that the temperature forms a clear periodic pattern, where the temperature drops overnight and rises during daytime. Overall, both temperature and humidity increases from new year to January 15th as the spikes are getting larger and the scatters are becoming lighter.

Finally, to save this scatterplot with 'ggsave':
```{r}
ggsave(filename = "temp_vs_time.png", plot = plot_time_temp)
```

### Problem 2
First, we import the tidyverse library:
```{r}
library(tidyverse)
```
Now we create a tibble object with name 'desired_df' and assign values to it. Since we are creating random samples, first set a seed for reproducibility:
```{r}
set.seed(10)
desired_df = tibble(
  random_nums = rnorm(10),
  logicals = random_nums > 0,
  characters = c("a","b","c","d","e","f","g","h","i","k"),
  factors = factor(sample(c("low","med","high"), 10, replace = TRUE))
)

desired_df
```
Next, we try to get the mean of each variable in this dataframe. We can get the mean of variable 'random_nums' with:
```{r}
mean(pull(desired_df, random_nums))
```
We can also get the mean of variable 'logicals':
```{r}
mean(pull(desired_df, logicals))
```
Getting the mean from the variable 'characters' gives us a warning: "argument is not numeric or logical: returning NA"
```{r}
mean(pull(desired_df, characters))
```
Getting the mean from the variable 'factors' gives the same warning as well:
```{r}
mean(pull(desired_df, factors))
```
Next we try to convert the non-numeric values to numeric values with 'as.numeric':
```{r, echo=TRUE, results='hide', warning=FALSE, message=FALSE}
as.numeric(pull(desired_df, logicals))
as.numeric(pull(desired_df, characters))
as.numeric(pull(desired_df, factors))
```
For logical values, they have a numeric form of True=1 and False=0, therefore they can be properly transformed and be treated as numeric values. This explains why logical values can have a mean. For character values, there does not exist a map between number and characters, so they are forced to become null values (NA), this also explains why we previously saw a warning. For factor values, they are forced to numeric values based on their factor level (In this case "high" to 1 "med" to 3 and "low" to 2), but factor variables themselves cannot be treated as numeric values and therefore cannot have a mean.



